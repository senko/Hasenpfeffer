/*****************************************************************
 * Source file : TaskManager.idl
 * Platform    : V4 IA32
 * Mapping     : CORBA C
 * 
 * Generated by IDL4 1.0.2 (roadrunner) on 30/12/2005 22:18
 * Report bugs to haeberlen@ira.uka.de
 *****************************************************************/

#define IDL4_ARCH ia32
#define IDL4_API v4
#define IDL4_OMIT_FRAME_POINTER 0

#include <stdlib.h>
#include <idl4/idl4.h>
#include <server/TaskManager.h>
#include <memory.h>
#include <thread.h>
#include <l4/kdebug.h>
#include <capability.h>
#include <l4io.h>
#include <debug.h>

static L4_Word_t my_secret;

#define HPF_CAP_TASKMAN_NEW_THREAD 256
#define HPF_CAP_TASKMAN_NEW_TASK 512

/* Interface TaskManager */

IDL4_INLINE CORBA_boolean TaskManager_NewTask_implementation(CORBA_Object _caller, const Capability_t *cap, const Thread_t pager, const Thread_t scheduler, Capability_t *newcap, idl4_server_environment *_env)
{
    HpfCapability *hcap = (HpfCapability *) cap;

    if (!(hcap->flags & HPF_CAP_TASKMAN_NEW_TASK) || !hpf_capability_check(hcap, my_secret)) {
        return 0;
    }

    L4_ThreadId_t pager_tid;
    pager_tid.raw = pager;

    AddrSpace_t *as = task_new(pager_tid);
    if (!as) return 0;

    hcap = (HpfCapability *) newcap;
    address_space_get_capability(hcap, as, HPF_CAP_PERM_FULL);

    return 1;
}

IDL4_PUBLISH_TASKMANAGER_NEWTASK(TaskManager_NewTask_implementation);

IDL4_INLINE CORBA_boolean TaskManager_NewThread_implementation(CORBA_Object _caller, const Capability_t *cap, const Thread_t space, const Thread_t pager, const Thread_t scheduler, Capability_t *newcap, idl4_server_environment *_env)
{
    HpfCapability *hcap = (HpfCapability *) cap;

    if (!(hcap->flags & HPF_CAP_TASKMAN_NEW_THREAD) || !hpf_capability_check(hcap, my_secret)) {
        return 0;
    }

    L4_ThreadId_t pager_tid;
    pager_tid.raw = pager;
    L4_ThreadId_t space_tid;
    space_tid.raw = space;

    AddrSpace_t *as = thread_get_address_space(space_tid);
    if (!as) return 0;

    L4_ThreadId_t tid = thread_new(as);
    if (L4_IsNilThread(tid)) return 0;

    hcap = (HpfCapability *) newcap;
    thread_get_capability(hcap, tid, HPF_CAP_PERM_FULL);

    return 1;
}

IDL4_PUBLISH_TASKMANAGER_NEWTHREAD(TaskManager_NewThread_implementation);

IDL4_INLINE CORBA_boolean TaskManager_DestroyTask_implementation(CORBA_Object _caller, const Capability_t *cap, idl4_server_environment *_env)

{
  CORBA_boolean __retval = 0;

  /* implementation of TaskManager::DestroyTask */
  
  return __retval;
}

IDL4_PUBLISH_TASKMANAGER_DESTROYTASK(TaskManager_DestroyTask_implementation);

IDL4_INLINE CORBA_boolean TaskManager_DestroyThread_implementation(CORBA_Object _caller, const Capability_t *cap, idl4_server_environment *_env)
{
    HpfCapability *hcap = (HpfCapability *) cap;

    if (!HPF_CAP_CAN_WRITE(*hcap)) {
        return 0;
    }

    thread_t *tt = thread_from_capability(hcap);
    if (!tt) {
        return 0;
    }

    L4_ThreadId_t tid = _caller;
    debug("[task manager - client %lx, destroying thread: %lx]\n", tid.raw, tt->tid.raw);
    if (thread_destroy(tt->tid)) {
        if (tt->tid.raw == tid.raw) {
            idl4_set_no_response(_env);
        }
        return 1;
    }
    return 0;
}

IDL4_PUBLISH_TASKMANAGER_DESTROYTHREAD(TaskManager_DestroyThread_implementation);

IDL4_INLINE CORBA_boolean TaskManager_RequestTaskDestroyNotification_implementation(CORBA_Object _caller, const Capability_t *cap, idl4_server_environment *_env)

{
  CORBA_boolean __retval = 0;

  /* implementation of TaskManager::RequestTaskDestroyNotification */
  
  return __retval;
}

IDL4_PUBLISH_TASKMANAGER_REQUESTTASKDESTROYNOTIFICATION(TaskManager_RequestTaskDestroyNotification_implementation);

IDL4_INLINE CORBA_boolean TaskManager_RequestThreadDestroyNotification_implementation(CORBA_Object _caller, const Capability_t *cap, idl4_server_environment *_env)

{
  CORBA_boolean __retval = 0;

  /* implementation of TaskManager::RequestThreadDestroyNotification */
  
  return __retval;
}

IDL4_PUBLISH_TASKMANAGER_REQUESTTHREADDESTROYNOTIFICATION(TaskManager_RequestThreadDestroyNotification_implementation);

IDL4_INLINE CORBA_boolean TaskManager_GetMyCapability_implementation(CORBA_Object _caller, Capability_t *newcap, idl4_server_environment *_env)

{
  L4_ThreadId_t tid = _caller;
  HpfCapability *hcap = (HpfCapability *) newcap;
  thread_get_capability(hcap, tid, HPF_CAP_PERM_FULL);
  
  return 1;
}

IDL4_PUBLISH_TASKMANAGER_GETMYCAPABILITY(TaskManager_GetMyCapability_implementation);

IDL4_INLINE CORBA_boolean TaskManager_LessenCapability_implementation(CORBA_Object _caller, const Capability_t *cap, const Word_t flags, Capability_t *newcap, idl4_server_environment *_env)

{
  CORBA_boolean __retval = 0;

  /* implementation of TaskManager::LessenCapability */
  
  return __retval;
}

IDL4_PUBLISH_TASKMANAGER_LESSENCAPABILITY(TaskManager_LessenCapability_implementation);

void *TaskManager_vtable[TASKMANAGER_DEFAULT_VTABLE_SIZE] = TASKMANAGER_DEFAULT_VTABLE;

void TaskManager_server(void)

{
  L4_ThreadId_t partner;
  L4_MsgTag_t msgtag;
  idl4_msgbuf_t msgbuf;
  long cnt;

  idl4_msgbuf_init(&msgbuf);
//  for (cnt = 0;cnt < TASKMANAGER_STRBUF_SIZE;cnt++)
//    idl4_msgbuf_add_buffer(&msgbuf, malloc(8000), 8000);

  while (1)
    {
      partner = L4_nilthread;
      msgtag.raw = 0;
      cnt = 0;

      while (1)
        {
          idl4_msgbuf_sync(&msgbuf);

          idl4_reply_and_wait(&partner, &msgtag, &msgbuf, &cnt);

          if (idl4_is_error(&msgtag))
            break;

          idl4_process_request(&partner, &msgtag, &msgbuf, &cnt, TaskManager_vtable[idl4_get_function_id(&msgtag) & TASKMANAGER_FID_MASK]);
        }
    }
}

void TaskManager_discard(void)

{
}

void task_manager_main(void)
{
    printf("Task manager ready and waiting for clients.\n");
    TaskManager_server();
}

void task_manager_init(HpfCapability *full, HpfCapability *newtask, HpfCapability *newthread)
{
    my_secret = rand();
    hpf_capability_new(full, L4_Myself(), 0, HPF_CAP_PERM_FULL, my_secret);
    hpf_capability_new(newtask, L4_Myself(), 0, HPF_CAP_TASKMAN_NEW_TASK, my_secret);
    hpf_capability_new(newthread, L4_Myself(), 0, HPF_CAP_TASKMAN_NEW_THREAD, my_secret);
}

