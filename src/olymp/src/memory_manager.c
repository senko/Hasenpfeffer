/*****************************************************************
 * Source file : interfaces/Pager.idl
 * Platform    : V4 IA32
 * Mapping     : CORBA C
 * 
 * Generated by IDL4 1.0.2 (roadrunner) on 30/12/2005 06:47
 * Report bugs to haeberlen@ira.uka.de
 *****************************************************************/

#define IDL4_ARCH ia32
#define IDL4_API v4
#define IDL4_OMIT_FRAME_POINTER 0

#include <stdlib.h>
#include <idl4/idl4.h>
#include <server/Pager.h>
#include <memory.h>
#include <thread.h>
#include <l4/kdebug.h>
#include <l4io.h>
#include <debug.h>

/* Interface Pager */

IDL4_INLINE void Pager_pagefault_implementation(CORBA_Object _caller, const IntPtr_t addr, const IntPtr_t uip, const CORBA_short privileges, idl4_fpage_t *page, idl4_server_environment *_env)

{
    L4_ThreadId_t tid = _caller;
    L4_Fpage_t vp, fp;
    AddrSpace_t *as;
    mempage_t *mp;

//    printf("[mman: pagefault request received from %lx at %lx]\n", tid, addr);
    // FIXME - this is a temporary hack!!!
    {
        L4_Word_t foo = addr - (addr % PAGE_SIZE);
        if (foo == 0xb8000) {
//            printf("[mman: mapping video memory area]\n");
            idl4_fpage_set_base(page, foo);
            idl4_fpage_set_page(page, L4_Fpage(foo, PAGE_SIZE));
            idl4_fpage_set_permissions(page, IDL4_PERM_FULL);
            idl4_fpage_set_mode(page, IDL4_MODE_MAP);
            return;
        }
        if ((foo == 0x0)) {
            L4_KDB_Enter("task requested page 0x0 - better hope it's for I/O purposes");
//            printf("[mman: mapping ata/atapi memory area]\n");
            idl4_fpage_set_base(page, foo);
            idl4_fpage_set_page(page, L4_Fpage(0, PAGE_SIZE)); // remapping trick! so 0
            idl4_fpage_set_permissions(page, IDL4_PERM_FULL);
            idl4_fpage_set_mode(page, IDL4_MODE_MAP);
            return;
        }
        /* all other requests for space below 1M limit is not served */
        if (foo < 0x100000) {
            printf("[mman: invalid pagefault @ %lx not served: client = %lx]\n", foo, tid.raw);
            idl4_set_no_response(_env);
            L4_KDB_Enter("after invalid pagefault (SIGSEGV)");
            return;
        }
    }
    
    as = thread_get_address_space(tid);
    if (!as) {
        idl4_set_no_response(_env);
        return;
    }
    mp = address_space_contains(as, addr);

    if (!mp) {
        vp = L4_Fpage(addr - (addr % PAGE_SIZE), PAGE_SIZE);
        fp = address_space_request_page(as, vp);
        if (L4_IsNilFpage(fp)) {
            idl4_set_no_response(_env);
            return;
        }
    } else {
        vp = mp->v_page;
        fp = mp->p_page;
    }

    debug("pagefault: %lx vpage: [%lx:%lx] ppage: [%lx:%lx]\n", (unsigned long) addr, L4_Address(vp), L4_Size(vp), L4_Address(fp), L4_Size(fp));

    idl4_fpage_set_base(page, L4_Address(vp));
    idl4_fpage_set_page(page, fp);
    idl4_fpage_set_permissions(page, IDL4_PERM_FULL);
    idl4_fpage_set_mode(page, IDL4_MODE_MAP);
    return;
}

IDL4_PUBLISH_PAGER_PAGEFAULT(Pager_pagefault_implementation);

IDL4_INLINE CORBA_boolean Pager_RequestPage_implementation(CORBA_Object _caller, const IntPtr_t addr, const Word_t size, idl4_fpage_t *page, idl4_server_environment *_env)

{
  CORBA_boolean __retval = 0;

  /* implementation of Pager::RequestPage */
  
  return __retval;
}

IDL4_PUBLISH_PAGER_REQUESTPAGE(Pager_RequestPage_implementation);

IDL4_INLINE CORBA_boolean Pager_ReleasePage_implementation(CORBA_Object _caller, const IntPtr_t addr, const Word_t size, idl4_server_environment *_env)

{
  CORBA_boolean __retval = 0;

  /* implementation of Pager::ReleasePage */
  
  return __retval;
}

IDL4_PUBLISH_PAGER_RELEASEPAGE(Pager_ReleasePage_implementation);

IDL4_INLINE CORBA_boolean Pager_TransferPage_implementation(CORBA_Object _caller, const Capability_t *cap, const IntPtr_t addr, const Word_t size, const IntPtr_t dest_addr, const Word_t dest_size, idl4_server_environment *_env)

{
  CORBA_boolean __retval = 0;

  /* implementation of Pager::TransferPage */
  
  return __retval;
}

IDL4_PUBLISH_PAGER_TRANSFERPAGE(Pager_TransferPage_implementation);

void *Pager_vtable[PAGER_DEFAULT_VTABLE_SIZE] = PAGER_DEFAULT_VTABLE;
void *Pager_ktable[PAGER_DEFAULT_KTABLE_SIZE] = PAGER_DEFAULT_KTABLE;

void Pager_server(void)

{
  L4_ThreadId_t partner;
  L4_MsgTag_t msgtag;
  idl4_msgbuf_t msgbuf;
  long cnt;

  idl4_msgbuf_init(&msgbuf);
#if (PAGER_STRBUF_SIZE > 0)
  for (cnt = 0;cnt < PAGER_STRBUF_SIZE;cnt++)
    idl4_msgbuf_add_buffer(&msgbuf, malloc(8000), 8000);
#endif
  while (1)
    {
      partner = L4_nilthread;
      msgtag.raw = 0;
      cnt = 0;

      while (1)
        {
          idl4_msgbuf_sync(&msgbuf);

          idl4_reply_and_wait(&partner, &msgtag, &msgbuf, &cnt);

          if (idl4_is_error(&msgtag))
            break;

          if (IDL4_EXPECT_FALSE(idl4_is_kernel_message(msgtag)))
            idl4_process_request(&partner, &msgtag, &msgbuf, &cnt, Pager_ktable[idl4_get_kernel_message_id(msgtag) & PAGER_KID_MASK]);
            else idl4_process_request(&partner, &msgtag, &msgbuf, &cnt, Pager_vtable[idl4_get_function_id(&msgtag) & PAGER_FID_MASK]);
        }
    }
}

void Pager_discard(void)

{
}

