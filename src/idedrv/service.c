/*****************************************************************
 * Source file : File.idl
 * Platform    : V4 IA32
 * Mapping     : CORBA C
 * 
 * Generated by IDL4 1.0.2 (roadrunner) on 06/01/2006 20:37
 * Report bugs to haeberlen@ira.uka.de
 *****************************************************************/

#define IDL4_ARCH ia32
#define IDL4_API v4
#define IDL4_OMIT_FRAME_POINTER 0

#include <l4io.h>

#include <stdlib.h>
#include <string.h>
#include <l4/kdebug.h>
#include <idl4/idl4.h>
#include <capability.h>
#include <dir.h>
#include <server/File.h>

#include "mindrvr.h"

static L4_Word_t my_secret;
static HpfCapability file_cap;

static unsigned char ide_device;
unsigned long dev_size;


/* Interface File */

#define MAX_OUTPUT_LEN 4096

/* max output + one sector */
static char cache[MAX_OUTPUT_LEN + 512];

IDL4_INLINE CORBA_boolean File_Read_implementation(CORBA_Object _caller, const Capability_t *cap, const CORBA_unsigned_long offset, byteseq_t *seq, CORBA_unsigned_long *size, idl4_server_environment *_env)
{
    HpfCapability *hcap = (HpfCapability *) cap;

    unsigned char **buffer = &seq->_buffer;

    if (!HPF_CAP_CAN_WRITE(*hcap) || !hpf_capability_check(hcap, my_secret)) {
        return 0;
    }

//    printf("got request for %ld %ld bytes at %lx\n", *size, seq->_length, offset);
    // FIXME - ugllyyyyy.... we really don't want hardcoded values :(
    if (*size >= MAX_OUTPUT_LEN) return 0;
    
    uint32_t first_sect = offset / 512;
    uint32_t last_sect = (offset + *size) / 512;
    uint32_t n_sects = last_sect - first_sect;

//    printf("that's %d sectors [%lx - %lx]\n", n_sects, first_sect, last_sect);

//    printf("issuing read command\n");
    int ret = reg_pio_data_in_lba48(ide_device, CMD_READ_SECTORS, 0, n_sects, 0, first_sect, cache, n_sects, 0);
//    printf("driver return value: %d\n", ret);

    if (ret != 0) return 0;

    seq->_length = *size;

    *buffer = cache + (offset % 512);
    return 1;

}

IDL4_PUBLISH_FILE_READ(File_Read_implementation);

IDL4_INLINE CORBA_unsigned_long File_Write_implementation(CORBA_Object _caller, const Capability_t *cap, const CORBA_unsigned_long offset, const CORBA_char *buffer, const CORBA_unsigned_long size, idl4_server_environment *_env)
{
    HpfCapability *hcap = (HpfCapability *) cap;

    if (!HPF_CAP_CAN_WRITE(*hcap) || !hpf_capability_check(hcap, my_secret)) {
        return 0;
    }

    /* not implemented yet */
    return 0;
}

IDL4_PUBLISH_FILE_WRITE(File_Write_implementation);

IDL4_INLINE CORBA_unsigned_long File_Size_implementation(CORBA_Object _caller, const Capability_t *cap, idl4_server_environment *_env)

{
    HpfCapability *hcap = (HpfCapability *) cap;

    if (!HPF_CAP_CAN_WRITE(*hcap) || !hpf_capability_check(hcap, my_secret)) {
        return 0;
    }
    return dev_size;
}

IDL4_PUBLISH_FILE_SIZE(File_Size_implementation);

void *File_vtable[FILE_DEFAULT_VTABLE_SIZE] = FILE_DEFAULT_VTABLE;

void File_server(void)

{
  L4_ThreadId_t partner;
  L4_MsgTag_t msgtag;
  idl4_msgbuf_t msgbuf;
  long cnt;

  idl4_msgbuf_init(&msgbuf);
  for (cnt = 0;cnt < FILE_STRBUF_SIZE;cnt++)
    idl4_msgbuf_add_buffer(&msgbuf, malloc(8000), 8000);

  while (1)
    {
      partner = L4_nilthread;
      msgtag.raw = 0;
      cnt = 0;

      while (1)
        {
          idl4_msgbuf_sync(&msgbuf);

          idl4_reply_and_wait(&partner, &msgtag, &msgbuf, &cnt);

          if (idl4_is_error(&msgtag))
            break;

//          printf("client %lx requested service %d\n", partner.raw, idl4_get_function_id(&msgtag) & FILE_FID_MASK);
          idl4_process_request(&partner, &msgtag, &msgbuf, &cnt, File_vtable[idl4_get_function_id(&msgtag) & FILE_FID_MASK]);
        }
    }
}

void File_discard(void)
{
}

void service_init(HpfCapability *cap, unsigned char dev, unsigned long size)
{
    my_secret = rand();
    hpf_capability_new(&file_cap, L4_Myself(), 0, HPF_CAP_PERM_FULL, my_secret);
    *cap = file_cap;
    ide_device = dev;
    dev_size = size;
}

void service_main()
{
    printf("IDE driver ready and waiting for clients.\n");
    File_server();
}

