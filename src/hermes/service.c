/*****************************************************************
 * Source file : DirectoryService.idl
 * Platform    : V4 IA32
 * Mapping     : CORBA C
 * 
 * Generated by IDL4 1.0.2 (roadrunner) on 05/01/2006 03:09
 * Report bugs to haeberlen@ira.uka.de
 *****************************************************************/

#define IDL4_ARCH ia32
#define IDL4_API v4
#define IDL4_OMIT_FRAME_POINTER 0

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <idl4/idl4.h>
#include <l4/kdebug.h>
#include <capability.h>
#include <dir.h>
#include <server/DirectoryService.h>

static L4_Word_t my_secret;
static L4_ThreadId_t root;

static HpfCapability full_cap;
static HpfDirectory dir;

#define HPF_CAP_DIRENT_DESTROY 256
#define HPF_CAP_DIRENT_FULL (HPF_CAP_DIRENT_DESTROY | HPF_CAP_PERM_FULL)

/* Interface DirectoryService */

IDL4_INLINE CORBA_boolean DirectoryService_RegisterPath_implementation(CORBA_Object _caller, const Capability_t *cap, const CORBA_char *path, const Capability_t *object, Capability_t *newcap, idl4_server_environment *_env)

{
    HpfCapability *hcap = (HpfCapability *) cap;

    if (path[0] != '/') return 0;

    if (!(hcap->flags & HPF_CAP_PERM_WRITE) || !hpf_capability_check(hcap, my_secret)) {
        return 0;
    }

    HpfDirEntry *ent = (HpfDirEntry *) hcap->object;
    char *p = (char *) path;

    if (ent) {
        int l = strlen(ent->name) + strlen(path) + 1;
        p = malloc(l);
        if (!p) return 0;
        snprintf(p, l, "%s%s", ent->name, path);
    }

//    printf("registering new path: '%s'\n", p);
    HpfCapability *ocap = (HpfCapability *) object;
    ent = hpf_directory_add(&dir, p, *ocap);
    if (!ent) {
        if (p != path) free(p);
        return 0;
    }

    hcap = (HpfCapability *) newcap;
    hpf_capability_new(hcap, L4_Myself(), (L4_Word_t) ent, HPF_CAP_DIRENT_FULL, my_secret);

    if (p != path) free(p);
    return 1;
}

IDL4_PUBLISH_DIRECTORYSERVICE_REGISTERPATH(DirectoryService_RegisterPath_implementation);

IDL4_INLINE CORBA_boolean DirectoryService_UnregisterPath_implementation(CORBA_Object _caller, const Capability_t *cap, idl4_server_environment *_env)

{
  CORBA_boolean __retval = 0;

  /* implementation of DirectoryService::UnregisterPath */
  
  return __retval;
}

IDL4_PUBLISH_DIRECTORYSERVICE_UNREGISTERPATH(DirectoryService_UnregisterPath_implementation);

IDL4_INLINE CORBA_boolean DirectoryService_ResolvePath_implementation(CORBA_Object _caller, const Capability_t *cap, const CORBA_char *path, Capability_t *object, CORBA_long *resolved_chars, idl4_server_environment *_env)

{
    HpfCapability *hcap = (HpfCapability *) cap;

    if (path[0] != '/') return 0;

    if (!(hcap->flags & HPF_CAP_PERM_WRITE) || !hpf_capability_check(hcap, my_secret)) {
        return 0;
    }

    HpfDirEntry *ent = (HpfDirEntry *) hcap->object;
    char *p = (char *) path;
    int internal_chars = 0;

    if (ent) {
        int l = strlen(ent->name) + strlen(path) + 1;
        p = malloc(l);
        if (!p) return 0;
        snprintf(p, l, "%s%s", ent->name, path);
        internal_chars = strlen(ent->name);
    }

//    printf("resolving path: '%s'\n", p);
    ent = hpf_directory_resolve(&dir, p, resolved_chars);
    if (!ent) {
        if (p != path) free(p);
        return 0;
    }

    *resolved_chars -= internal_chars;
    if (p != path) free(p);

    hcap = (HpfCapability *) object;
    *hcap = ent->cap;

    return 1;
}

IDL4_PUBLISH_DIRECTORYSERVICE_RESOLVEPATH(DirectoryService_ResolvePath_implementation);

IDL4_INLINE CORBA_boolean DirectoryService_LessenCapability_implementation(CORBA_Object _caller, const Capability_t *cap, const Word_t flags, Capability_t *newcap, idl4_server_environment *_env)

{
  CORBA_boolean __retval = 0;

  /* implementation of DirectoryService::LessenCapability */
  
  return __retval;
}

IDL4_PUBLISH_DIRECTORYSERVICE_LESSENCAPABILITY(DirectoryService_LessenCapability_implementation);

IDL4_INLINE CORBA_boolean DirectoryService_GetRootCapability_implementation(CORBA_Object _caller, Capability_t *newcap, idl4_server_environment *_env)

{

    L4_ThreadId_t caller = _caller;

    if (caller.raw != root.raw) {
        return 0;
    }

    HpfCapability *hcap = (HpfCapability *) newcap;
    *hcap = full_cap;

    return 1;
}

IDL4_PUBLISH_DIRECTORYSERVICE_GETROOTCAPABILITY(DirectoryService_GetRootCapability_implementation);

void *DirectoryService_vtable[DIRECTORYSERVICE_DEFAULT_VTABLE_SIZE] = DIRECTORYSERVICE_DEFAULT_VTABLE;

void DirectoryService_server(void)

{
  L4_ThreadId_t partner;
  L4_MsgTag_t msgtag;
  idl4_msgbuf_t msgbuf;
  long cnt;

  idl4_msgbuf_init(&msgbuf);
  for (cnt = 0;cnt < DIRECTORYSERVICE_STRBUF_SIZE;cnt++)
    idl4_msgbuf_add_buffer(&msgbuf, malloc(8000), 8000);

  while (1)
    {
      partner = L4_nilthread;
      msgtag.raw = 0;
      cnt = 0;

      while (1)
        {
          idl4_msgbuf_sync(&msgbuf);

          idl4_reply_and_wait(&partner, &msgtag, &msgbuf, &cnt);

          if (idl4_is_error(&msgtag))
            break;

          idl4_process_request(&partner, &msgtag, &msgbuf, &cnt, DirectoryService_vtable[idl4_get_function_id(&msgtag) & DIRECTORYSERVICE_FID_MASK]);
        }
    }
}

void DirectoryService_discard(void)

{
}


void service_init(L4_ThreadId_t tid)
{
    my_secret = rand();
    hpf_capability_new(&full_cap, L4_Myself(), 0, HPF_CAP_DIRENT_FULL, my_secret);
    root = tid;
}

void service_main()
{
    printf("Root directory service ready and waiting for clients.\n");
    DirectoryService_server();
}

