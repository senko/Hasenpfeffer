/*****************************************************************
 * Source file : File.idl
 * Platform    : V4 IA32
 * Mapping     : CORBA C
 * 
 * Generated by IDL4 1.0.2 (roadrunner) on 06/01/2006 20:37
 * Report bugs to haeberlen@ira.uka.de
 *****************************************************************/

#define IDL4_ARCH ia32
#define IDL4_API v4
#define IDL4_OMIT_FRAME_POINTER 0

#include <l4io.h>

#include <stdlib.h>
#include <string.h>
#include <idl4/idl4.h>
#include <l4/kdebug.h>
#include <capability.h>
#include <dir.h>
#include <server/File.h>

static L4_Word_t my_secret;
static HpfCapability file_cap;

/* Interface File */

IDL4_INLINE CORBA_boolean File_Read_implementation(CORBA_Object _caller, const Capability_t *cap, const CORBA_unsigned_long offset, byteseq_t *seq, CORBA_unsigned_long *size, idl4_server_environment *_env)
{
    HpfCapability *hcap = (HpfCapability *) cap;

    unsigned char **buffer = &seq->_buffer;
    seq->_length = *size;

    if (!HPF_CAP_CAN_WRITE(*hcap) || !hpf_capability_check(hcap, my_secret)) {
        return 0;
    }

    int i;
    for (i = 0; i < *size; i++) {
//        int x = getc();
        int x = L4_KDB_ReadChar_Blocked();
        if (x == '\r') x = '\n';
        putc(x);
        (*buffer)[i] = x;
    }
    return 1;
}

IDL4_PUBLISH_FILE_READ(File_Read_implementation);

IDL4_INLINE CORBA_unsigned_long File_Write_implementation(CORBA_Object _caller, const Capability_t *cap, const CORBA_unsigned_long offset, const CORBA_char *buffer, const CORBA_unsigned_long size, idl4_server_environment *_env)
{
    HpfCapability *hcap = (HpfCapability *) cap;

    if (!HPF_CAP_CAN_WRITE(*hcap) || !hpf_capability_check(hcap, my_secret)) {
        return 0;
    }

    int i;
    for (i = 0; i < size; i++) {
        putc(buffer[i]);
    }
    return size;
}

IDL4_PUBLISH_FILE_WRITE(File_Write_implementation);

IDL4_INLINE CORBA_unsigned_long File_Size_implementation(CORBA_Object _caller, const Capability_t *cap, idl4_server_environment *_env)

{
  CORBA_unsigned_long __retval = 0;

  /* implementation of File::Size */

  return __retval;
}

IDL4_PUBLISH_FILE_SIZE(File_Size_implementation);

void *File_vtable[FILE_DEFAULT_VTABLE_SIZE] = FILE_DEFAULT_VTABLE;

void File_server(void)

{
  L4_ThreadId_t partner;
  L4_MsgTag_t msgtag;
  idl4_msgbuf_t msgbuf;
  long cnt;

  idl4_msgbuf_init(&msgbuf);
  for (cnt = 0;cnt < FILE_STRBUF_SIZE;cnt++)
    idl4_msgbuf_add_buffer(&msgbuf, malloc(8000), 8000);

  while (1)
    {
      partner = L4_nilthread;
      msgtag.raw = 0;
      cnt = 0;

      while (1)
        {
          idl4_msgbuf_sync(&msgbuf);

          idl4_reply_and_wait(&partner, &msgtag, &msgbuf, &cnt);

          if (idl4_is_error(&msgtag))
            break;

          idl4_process_request(&partner, &msgtag, &msgbuf, &cnt, File_vtable[idl4_get_function_id(&msgtag) & FILE_FID_MASK]);
        }
    }
}

void File_discard(void)

{
}

void service_init(HpfCapability *cap)
{
    my_secret = rand();
    hpf_capability_new(&file_cap, L4_Myself(), 0, HPF_CAP_PERM_FULL, my_secret);
    *cap = file_cap;
}

void service_main()
{
    printf("Console driver ready and waiting for clients.\n");
    File_server();
}

